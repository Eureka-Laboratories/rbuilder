use std::sync::{Arc, Mutex};

use ahash::HashMap;

use crate::building::builders::{
    block_building_helper::BiddableUnfinishedBlock, UnfinishedBlockBuildingSink,
};

/// Multiplexes the input from several building algos by forwarding best block among the last blocks
/// received from each algo. Algos are identified by block().builder_name()
pub struct UnfinishedBlockBuildingSinkMuxer {
    /// needed state to check and update the best block.
    best_block_state: Mutex<BestBlockState>,
    /// Here we push the best blocks.
    sink: Arc<dyn UnfinishedBlockBuildingSink>,
}

impl UnfinishedBlockBuildingSinkMuxer {
    pub fn new(sink: Arc<dyn UnfinishedBlockBuildingSink>) -> Self {
        Self {
            best_block_state: Mutex::new(BestBlockState::new()),
            sink,
        }
    }
}

impl UnfinishedBlockBuildingSink for UnfinishedBlockBuildingSinkMuxer {
    fn new_block(&self, block: BiddableUnfinishedBlock) {
        if let Some(best_biddable_block) = self
            .best_block_state
            .lock()
            .unwrap()
            .update_best_block(block)
        {
            self.sink.new_block(best_biddable_block);
        }
    }

    fn can_use_suggested_fee_recipient_as_coinbase(&self) -> bool {
        self.sink.can_use_suggested_fee_recipient_as_coinbase()
    }
}

impl std::fmt::Debug for UnfinishedBlockBuildingSinkMuxer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("UnfinishedBlockBuildingSinkMuxer").finish()
    }
}

/// Computes the best block among all the algos.
struct BestBlockState {
    /// For each algo name we store the last block so on each update we can look for the best block among all algos.
    /// We should replace String for "real" type identifying the algo.
    algorithm_to_last_block: HashMap<String, BiddableUnfinishedBlock>,
    /// Works as an id for the last block so we don't send the same twice since the same block could be generated by different algos.
    last_sent_block_hash: Option<u64>,
}

impl BestBlockState {
    fn new() -> Self {
        Self {
            algorithm_to_last_block: Default::default(),
            last_sent_block_hash: None,
        }
    }

    /// Given a new BiddableUnfinishedBlock updates the best per algo and return the best one if
    /// changes from last time.
    fn update_best_block(
        &mut self,
        biddable_block: BiddableUnfinishedBlock,
    ) -> Option<BiddableUnfinishedBlock> {
        self.algorithm_to_last_block.insert(
            biddable_block.block().builder_name().to_string(),
            biddable_block,
        );
        let best_biddable_block = self
            .algorithm_to_last_block
            .values()
            .max_by_key(|bb| bb.true_block_value())
            .unwrap();
        let best_block_hash = best_biddable_block
            .block()
            .built_block_trace()
            .transactions_hash();
        if self
            .last_sent_block_hash
            .as_ref()
            .is_none_or(|hash| *hash != best_block_hash)
        {
            self.last_sent_block_hash = Some(best_block_hash);
            Some(best_biddable_block.clone())
        } else {
            None
        }
    }
}

#[cfg(test)]
mod tests {
    use revm_primitives::U256;

    use crate::{
        building::{
            builders::{
                block_building_helper::BiddableUnfinishedBlock,
                mock_block_building_helper::MockBlockBuildingHelper,
            },
            ExecutionResult,
        },
        primitives::{AccountNonce, Order},
    };

    use super::BestBlockState;

    struct TestDataGenerator {
        base: crate::primitives::TestDataGenerator,
    }
    impl TestDataGenerator {
        fn new() -> Self {
            Self {
                base: Default::default(),
            }
        }

        /// Creates a unique block with true_block_value / builder_name
        fn create_block(
            &mut self,
            true_block_value: U256,
            builder_name: &str,
        ) -> BiddableUnfinishedBlock {
            let mut block = MockBlockBuildingHelper::new(true_block_value, true)
                .with_builder_name(builder_name.to_string());
            let order = self.base.create_mempool_tx(AccountNonce::default());
            let tx = order.tx_with_blobs.clone();
            // Give unique identity
            block
                .built_block_trace_mut_ref()
                .included_orders
                .push(ExecutionResult {
                    coinbase_profit: Default::default(),
                    inplace_sim: Default::default(),
                    gas_used: Default::default(),
                    order: Order::Tx(order),
                    txs: vec![tx],
                    original_order_ids: Default::default(),
                    receipts: Default::default(),
                    nonces_updated: Default::default(),
                    paid_kickbacks: Default::default(),
                });
            BiddableUnfinishedBlock::new(Box::new(block)).unwrap()
        }
    }

    const NAME_1: &str = "NAME1";
    const NAME_2: &str = "NAME2";
    const LOW_VAL: u64 = 10;
    const HIGH_VAL: u64 = 100;

    #[test]
    fn first_block() {
        let mut data_gen = TestDataGenerator::new();
        let mut state = BestBlockState::new();
        let block = data_gen.create_block(U256::from(LOW_VAL), NAME_1);
        let best_block = state.update_best_block(block.clone());
        assert_eq!(
            block.true_block_value(),
            best_block.unwrap().true_block_value()
        );
    }

    ///Send block and then send a better one from other builder, the new one should win.
    #[test]
    fn better_block_not_same_as_winning_builder() {
        let mut data_gen = TestDataGenerator::new();
        let mut state = BestBlockState::new();
        let block_low = data_gen.create_block(U256::from(LOW_VAL), NAME_1);
        let block_high = data_gen.create_block(U256::from(HIGH_VAL), NAME_2);
        let _ = state.update_best_block(block_low);
        let best_block = state.update_best_block(block_high.clone());
        assert_eq!(
            block_high.true_block_value(),
            best_block.unwrap().true_block_value()
        );
    }

    ///Send block and then send a better one from the same builder, the new one should win.
    #[test]
    fn better_block_same_winning_builder() {
        let mut data_gen = TestDataGenerator::new();
        let mut state = BestBlockState::new();
        let block_low = data_gen.create_block(U256::from(LOW_VAL), NAME_1);
        let block_high = data_gen.create_block(U256::from(HIGH_VAL), NAME_1);
        let _ = state.update_best_block(block_low);
        let best_block = state.update_best_block(block_high.clone());
        assert_eq!(
            block_high.true_block_value(),
            best_block.unwrap().true_block_value()
        );
    }

    /// Send block and then send a worse one from the same builder, should lower the bid
    #[test]
    fn worse_block_same_winning_builder() {
        let mut data_gen = TestDataGenerator::new();
        let mut state = BestBlockState::new();
        let block_high = data_gen.create_block(U256::from(HIGH_VAL), NAME_1);
        let block_low = data_gen.create_block(U256::from(LOW_VAL), NAME_1);

        let _ = state.update_best_block(block_high);
        let best_block = state.update_best_block(block_low.clone());
        assert_eq!(
            block_low.true_block_value(),
            best_block.unwrap().true_block_value()
        );
    }

    /// Send block and then send a worse one from other builder, should not bid
    #[test]
    fn worse_block_not_same_as_winning_builder() {
        let mut data_gen = TestDataGenerator::new();
        let mut state = BestBlockState::new();
        let block_high = data_gen.create_block(U256::from(HIGH_VAL), NAME_1);
        let block_low = data_gen.create_block(U256::from(LOW_VAL), NAME_2);

        let _ = state.update_best_block(block_high);
        let best_block = state.update_best_block(block_low.clone());
        assert!(best_block.is_none());
    }

    /// Send the same winning block twice, second should be ignored
    #[test]
    fn exact_same_block_winning_builder() {
        let mut data_gen = TestDataGenerator::new();
        let mut state = BestBlockState::new();
        let block = data_gen.create_block(U256::from(LOW_VAL), NAME_1);

        let _ = state.update_best_block(block.clone());
        let best_block = state.update_best_block(block);
        assert!(best_block.is_none());
    }
}
